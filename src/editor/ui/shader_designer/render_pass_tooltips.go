package shader_designer

var renderPassTooltips = map[string]string{
	// vk.AttachmentDescription
	"Flags":          "This field is a bitmask, which is a way in Vulkan to pack multiple settings into a single number by using bits. It lets you specify extra properties or behaviors for the attachment. For example, one possible flag is VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT. This flag tells Vulkan that this attachment might share the same memory as another attachment, which can save memory if you're careful with how you use it. Think of it like two people sharing a desk—you save space, but you need to coordinate so you don't mess up each other's work. If you don't need any special properties like this, you can just set Flags to 0, meaning no extra behaviors are applied. This field is all about giving you flexibility to tweak how the attachment behaves in specific situations.",
	"Format":         "The Format field defines the type of data that the image view for this attachment will hold, such as how many color channels it has and how many bits are used for each. For instance, VK_FORMAT_R8G8B8A8_UNORM is a popular choice—it's a 32-bit format with 8 bits each for red, green, blue, and alpha (transparency). Think of this like choosing the right kind of paper for a drawing: watercolor paper for soft blends or graph paper for precise lines. In Vulkan, the format affects how the image looks (its quality) and how fast your program runs (its performance). Picking the right format is key because it ensures your rendered images look good while keeping your application efficient.",
	"Samples":        "This field sets the number of samples per pixel when using multisampling, a technique that smooths out jagged edges (called aliasing) in your rendered images. It uses a type called VkSampleCountFlagBits to define the value. For example, VK_SAMPLE_COUNT_1_BIT means no multisampling—just one sample per pixel, keeping things simple and lightweight. On the other hand, VK_SAMPLE_COUNT_4_BIT means four samples per pixel, which makes edges smoother but uses more memory and processing power. Imagine taking multiple snapshots of a pixel to average out the roughness—that's multisampling. Higher numbers like 8 or 16 give even better quality but cost more resources, so you'll need to balance quality and performance based on your needs.",
	"LoadOp":         "The LoadOp field in Vulkan controls what happens to the color and depth data in an attachment when a render pass starts. Think of it like preparing a canvas before painting: you can keep the existing picture intact (VK_ATTACHMENT_LOAD_OP_LOAD) if you need it for your next step, wipe it clean with a specific color or value (VK_ATTACHMENT_LOAD_OP_CLEAR) to start fresh, or ignore it entirely (VK_ATTACHMENT_LOAD_OP_DONT_CARE) if you're going to paint over it anyway. Choosing the right option helps your program run faster by avoiding unnecessary work, especially when the old data isn't needed.",
	"StoreOp":        "The StoreOp field decides what to do with the color and depth data in an attachment once the render pass is done. It's like finishing a piece of art and choosing whether to keep it or toss it: you can save the rendered result (VK_ATTACHMENT_STORE_OP_STORE) for display or use in another step, or discard it (VK_ATTACHMENT_STORE_OP_DONT_CARE) if it's no longer useful, like a temporary sketch. This choice matters because saving data you don't need can waste memory and slow things down, so it's a key way to optimize your graphics application.",
	"StencilLoadOp":  "The StencilLoadOp field determines how the stencil data in an attachment is handled at the beginning of a render pass. Stencil data acts like a template for special effects, such as shadows or outlines, in your rendering. You can preserve what's already there (VK_ATTACHMENT_LOAD_OP_LOAD) if you're building on previous work, reset it to a specific value (VK_ATTACHMENT_LOAD_OP_CLEAR) for a new task, or leave it undefined (VK_ATTACHMENT_LOAD_OP_DONT_CARE) if you'll overwrite it anyway. This setup ensures your stencil effects start correctly without wasting effort on unneeded data.",
	"StencilStoreOp": "The StencilStoreOp field controls what happens to the stencil data when the render pass ends. Imagine you've used a stencil to shape your image—do you keep it for later (VK_ATTACHMENT_STORE_OP_STORE) because another step needs it, or toss it (VK_ATTACHMENT_STORE_OP_DONT_CARE) since its job is finished? This decision helps manage resources efficiently: saving stencil data can be crucial for multi-step rendering, but keeping it unnecessarily might bog down performance, so choose wisely based on your rendering plan.",
	"InitialLayout":  "The InitialLayout field tells Vulkan how the image's data should be organized in memory when the render pass begins. In Vulkan, images can be in different layouts, which are like blueprints for how the data is arranged to make certain tasks (like rendering or reading) faster. For example, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL is a layout optimized for writing color data to the attachment. Think of it like setting up a workspace: you arrange your tools differently for painting versus sketching. Getting this right avoids delays from Vulkan rearranging the data behind the scenes, so it's about starting the render pass efficiently.",
	"FinalLayout":    "The FinalLayout field defines how the image's data should be organized when the render pass ends. This is all about preparing the attachment for its next job, whether that's showing it on the screen, using it as a texture, or something else. For instance, if it's going to be a texture in the next pass, you might use VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, which sets it up for efficient reading by shaders. It's like packing up your tools after one task to get ready for the next. Setting the correct final layout ensures smooth handoffs between stages of your rendering pipeline, keeping everything running efficiently.",

	// vk.AttachmentReference

	// vk.SubpassDescription

	// vk.SubpassDependency
}
