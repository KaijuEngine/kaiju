package shader_designer

var renderPassTooltips = map[string]string{
	// vk.AttachmentDescription
	"Flags":          "This field is a bitmask, which is a way in Vulkan to pack multiple settings into a single number by using bits. It lets you specify extra properties or behaviors for the attachment. For example, one possible flag is MAY_ALIAS_BIT. This flag tells Vulkan that this attachment might share the same memory as another attachment, which can save memory if you're careful with how you use it. Think of it like two people sharing a desk-you save space, but you need to coordinate so you don't mess up each other's work. If you don't need any special properties like this, you can just set Flags to 0, meaning no extra behaviors are applied. This field is all about giving you flexibility to tweak how the attachment behaves in specific situations.",
	"Format":         "The Format field defines the type of data that the image view for this attachment will hold, such as how many color channels it has and how many bits are used for each. For instance, R8G8B8A8_UNORM is a popular choice-it's a 32-bit format with 8 bits each for red, green, blue, and alpha (transparency). Think of this like choosing the right kind of paper for a drawing: watercolor paper for soft blends or graph paper for precise lines. In Vulkan, the format affects how the image looks (its quality) and how fast your program runs (its performance). Picking the right format is key because it ensures your rendered images look good while keeping your application efficient.",
	"Samples":        "This field sets the number of samples per pixel when using multisampling, a technique that smooths out jagged edges (called aliasing) in your rendered images. It uses a type called VkSampleCountFlagBits to define the value. For example, 1_BIT means no multisampling-just one sample per pixel, keeping things simple and lightweight. On the other hand, 4_BIT means four samples per pixel, which makes edges smoother but uses more memory and processing power. Imagine taking multiple snapshots of a pixel to average out the roughness-that's multisampling. Higher numbers like 8 or 16 give even better quality but cost more resources, so you'll need to balance quality and performance based on your needs.",
	"LoadOp":         "The LoadOp field in Vulkan controls what happens to the color and depth data in an attachment when a render pass starts. Think of it like preparing a canvas before painting: you can keep the existing picture intact (LOAD) if you need it for your next step, wipe it clean with a specific color or value (CLEAR) to start fresh, or ignore it entirely (DONT_CARE) if you're going to paint over it anyway. Choosing the right option helps your program run faster by avoiding unnecessary work, especially when the old data isn't needed.",
	"StoreOp":        "The StoreOp field decides what to do with the color and depth data in an attachment once the render pass is done. It's like finishing a piece of art and choosing whether to keep it or toss it: you can save the rendered result (STORE) for display or use in another step, or discard it (DONT_CARE) if it's no longer useful, like a temporary sketch. This choice matters because saving data you don't need can waste memory and slow things down, so it's a key way to optimize your graphics application.",
	"StencilLoadOp":  "The StencilLoadOp field determines how the stencil data in an attachment is handled at the beginning of a render pass. Stencil data acts like a template for special effects, such as shadows or outlines, in your rendering. You can preserve what's already there (LOAD) if you're building on previous work, reset it to a specific value (CLEAR) for a new task, or leave it undefined (CARE) if you'll overwrite it anyway. This setup ensures your stencil effects start correctly without wasting effort on unneeded data.",
	"StencilStoreOp": "The StencilStoreOp field controls what happens to the stencil data when the render pass ends. Imagine you've used a stencil to shape your image-do you keep it for later (STORE) because another step needs it, or toss it (DONT_CARE) since its job is finished? This decision helps manage resources efficiently: saving stencil data can be crucial for multi-step rendering, but keeping it unnecessarily might bog down performance, so choose wisely based on your rendering plan.",
	"InitialLayout":  "The InitialLayout field tells Vulkan how the image's data should be organized in memory when the render pass begins. In Vulkan, images can be in different layouts, which are like blueprints for how the data is arranged to make certain tasks (like rendering or reading) faster. For example, OPTIMAL is a layout optimized for writing color data to the attachment. Think of it like setting up a workspace: you arrange your tools differently for painting versus sketching. Getting this right avoids delays from Vulkan rearranging the data behind the scenes, so it's about starting the render pass efficiently.",
	"FinalLayout":    "The FinalLayout field defines how the image's data should be organized when the render pass ends. This is all about preparing the attachment for its next job, whether that's showing it on the screen, using it as a texture, or something else. For instance, if it's going to be a texture in the next pass, you might use SHADER_READ_ONLY_OPTIMAL, which sets it up for efficient reading by shaders. It's like packing up your tools after one task to get ready for the next. Setting the correct final layout ensures smooth handoffs between stages of your rendering pipeline, keeping everything running efficiently.",

	// vk.AttachmentReference
	"Attachment": "The Attachment field is a number (specifically a uint32, which is an unsigned 32-bit integer) that identifies which attachment description this reference points to in the render pass. Imagine you've got a list of attachments-like color or depth buffers-defined earlier in your VkRenderPass; this number is the index into that list, starting at 0. For example, if you set Attachment to 1, it refers to the second attachment in the list. If you're not using an attachment here, you can set it to UNUSED (a special value, typically 0xFFFFFFFF), telling Vulkan to skip it. This field is like a label that connects this reference to the right piece of data you've set up.",
	"Layout":     "The Layout field specifies how the image data for this attachment should be organized in memory during the render pass, using a VkImageLayout value like OPTIMAL or OPTIMAL. Think of it as arranging your tools on a workbench: different layouts make certain tasks-like writing colors or reading depth-faster and more efficient. This layout can differ from the InitialLayout or FinalLayout in the attachment description because it's about how the image is used right now, in this specific step of rendering. Getting this right ensures Vulkan handles the data smoothly without slowing down to rearrange things mid-process.",

	// vk.SubpassDescription
	"PipelineBindPoint":      "The PipelineBindPoint field tells Vulkan what kind of pipeline this subpass will use, with options like GRAPHICS for graphics rendering (drawing stuff on the screen) or COMPUTE for compute tasks (number-crunching jobs). It's like picking the right tool for the job: a paintbrush for art or a calculator for math. For most rendering tasks, you'll pick graphics, as that's what subpasses are typically for-defining steps to create images in a render pass.",
	"InputAttachments":       "The pInputAttachments field is a pointer to an array of VkAttachmentReference structures, listing the attachments this subpass reads as inputs. Each entry points to an attachment (like a color or depth buffer) defined in the render pass and specifies its layout during this subpass. Think of it like a recipe card: it tells Vulkan, \"Grab these specific outputs from earlier and use them here.\" If InputAttachmentCount is 0, this can be null (empty), meaning no inputs are needed for this step.",
	"ColorAttachments":       "The pColorAttachments field points to an array of VkAttachmentReference structures, defining the color attachments this subpass writes to. Each entry links to an attachment from the render pass (like a color buffer) and sets its layout for writing, such as OPTIMAL. It's like handing Vulkan a list of buckets and saying, \"Fill these with the colors my shaders produce.\" If ColorAttachmentCount is 0, this can be null, meaning no color outputs for this subpass.",
	"ResolveAttachments":     "The pResolveAttachments field is a pointer to an array of VkAttachmentReference structures used for multisampling resolution. When you use multisampling (taking multiple samples per pixel for smoother edges), this array tells Vulkan where to store the final, single-sample result-like flattening multiple rough drafts into one polished image. Each entry matches a color attachment in pColorAttachments, and if you're not using multisampling, this can be null. It's an optional step to clean up after antialiasing.",
	"DepthStencilAttachment": "The pDepthStencilAttachment field points to a single VkAttachmentReference structure that defines the depth and/or stencil attachment for this subpass. This attachment handles depth (how far objects are from the camera) and stencil (a mask for special effects) data. Think of it as a special layer for tracking 3D space and outlines-if you don't need it, this can be null. It specifies which attachment to use and its layout, like OPTIMAL, so Vulkan knows how to manage this extra info.",
	"PreserveAttachments":    "The pPreserveAttachments field points to an array of uint32 values, each one an index into the render pass's attachment list, identifying which attachments to preserve. Unlike other attachments, these aren't read or written here-they're just safeguarded. Imagine locking a drawer so no one messes with your tools while you work on something else. If PreserveAttachmentCount is 0, this can be null, meaning nothing needs protecting in this subpass.",

	// vk.SubpassDependency
	"SrcSubpass":      "The SrcSubpass field is a uint32 that identifies the source subpass-the one that comes first in this dependency. It's an index into the list of subpasses in your render pass, starting at 0, or you can use EXTERNAL (a special value, -1) to mean \"something outside this render pass,\" like a previous operation. Think of it as naming the worker who's handing off a task: this is where the data or action starts before moving to the next step.",
	"DstSubpass":      "The DstSubpass field is another uint32 that specifies the destination subpass-the one that comes next and depends on the source. Like SrcSubpass, it's an index into the render pass's subpass list, or EXTERNAL (a special value, -1) if it's something after the render pass finishes. Imagine it as the worker receiving the task: this subpass needs the source's work to be done before it can start. Together with SrcSubpass, it sets up a \"before and after\" relationship.",
	"SrcStageMask":    "The SrcStageMask field uses VkPipelineStageFlags to pinpoint which part of the pipeline in the source subpass must finish before the next subpass can proceed. The pipeline is like an assembly line with stages-vertex processing, fragment shading, etc.-and this mask (a combination of bits) says, \"Wait until this stage is done.\" For example, OUTPUT_BIT means the color writing stage must complete. It's like telling a chef to finish chopping vegetables before someone else starts cooking with them.",
	"DstStageMask":    "The DstStageMask field, also a VkPipelineStageFlags bitmask, defines which pipeline stage in the destination subpass waits for the source to finish. This is the point where the next subpass says, \"I need that earlier work done before I start here.\" For instance, FRAGMENT_SHADER_BIT might mean the fragment shader needs the source's output (like a texture) before it can shade pixels. It's the other half of the timing handshake, ensuring things happen in the right order.",
	"SrcAccessMask":   "The SrcAccessMask field, using VkAccessFlags, describes what the source subpass is doing with memory-like reading or writing-that the destination needs to wait for. Values like WRITE_BIT mean the source is writing colors, or MEMORY_READ_BIT mean it's reading data. Think of it as listing what tools the first worker is using (e.g., a paintbrush) so the next worker knows when it's safe to grab them. This prevents conflicts by making sure memory operations are complete.",
	"DstAccessMask":   "The DstAccessMask field, another VkAccessFlags bitmask, specifies how the destination subpass will use memory and what it needs from the source. For example, READ_BIT means it's reading an input attachment, or WRITE_BIT means it's writing depth data. It's like telling Vulkan, \"I'll need to pick up where the last guy left off-make sure his work is ready.\" This pairs with SrcAccessMask to avoid data clashes, like two people writing on the same paper at once.",
	"DependencyFlags": "The DependencyFlags field is a bitmask (VkDependencyFlags) that adds extra rules to this dependency. One common option is BY_REGION_BIT, which means the dependency only applies within the same screen region, not the whole image-useful for efficiency in tile-based rendering (like splitting a big canvas into smaller pieces). Usually, you'll set this to 0 for no special behavior. It's like fine-tuning the handoff: \"Only wait for the part of the job I'm actually using.\"",

	// Render pass attachment image
	"MipLevels":            "The MipLevels field is a uint32 that specifies how many mipmap levels this image has. Mipmaps are smaller, pre-scaled versions of the image used to improve rendering quality and speed when objects are far away-like having a stack of photos in different sizes, from full detail to tiny thumbnails. A value of 1 means just the full-size image, while higher numbers (e.g., 4) mean additional smaller versions are included. This is set when creating the image and affects how it's used in rendering, especially for textures viewed at different distances.",
	"LayerCount":           "The LayerCount field, also a uint32, defines how many layers this image contains. Think of layers like pages in a flipbook: a 2D image has 1 layer, but a cube map (used for skyboxes) has 6 layers, one for each face, and a 3D texture might have many more. For a render pass attachment, this tells Vulkan how many slices of the image are available-usually 1 for simple color or depth buffers, but more for special cases like layered rendering. It's set when the image is created and determines how much data you're working with.",
	"Tiling":               "The Tiling field, using vk.ImageTiling, controls how the image's data is arranged in memory. Vulkan offers two main options: VK_IMAGE_TILING_LINEAR lays pixels out in a straightforward row-by-row grid (like a checkerboard you can easily read), which is great for CPU access but slower for GPUs; VK_IMAGE_TILING_OPTIMAL scrambles the layout into a GPU-friendly pattern (like a puzzle optimized for speed), ideal for rendering but harder to access directly. For render pass attachments, VK_IMAGE_TILING_OPTIMAL is usually best since it boosts performance when the GPU is drawing to the image.",
	"Filter":               "The Filter field, marked as vk.Filter, seems to specify how this image is sampled when used as a texture-like deciding how to blend colors if you zoom in or out. Options like VK_FILTER_NEAREST pick the closest pixel (blocky but fast), while VK_FILTER_LINEAR blends nearby pixels (smoother but slower). In Vulkan, this isn't typically part of an attachment description-it's set in a sampler or when sampling a texture in a shader. If this image becomes a texture later, this field hints at how it'll look, but for a render pass attachment, it's more about what's written to it than how it's read.",
	"Usage":                "The Usage field, a vk.ImageUsageFlags bitmask, defines what this image can do in your program. It's like giving it a job description: VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT means it can be a color buffer in a render pass, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT means it's for depth/stencil data, and VK_IMAGE_USAGE_SAMPLED_BIT means it can be a texture later. You can combine these (e.g., color attachment and sampled) to make the image versatile. This is set when creating the image and ensures it's ready for its role in the render pass.",
	"MemoryProperty":       "The MemoryProperty field, using vk.MemoryPropertyFlags, determines how the image's memory behaves. It's like choosing where to store your art supplies: VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT keeps it on the GPU for fast access (best for rendering), VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT lets the CPU see it (slower but useful for updates), or a mix of both. For render pass attachments, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT is typical since the GPU does the heavy lifting, but this is set when allocating memory for the image, not in the render pass itself.",
	"Aspect":               "The Aspect field, a vk.ImageAspectFlags bitmask, specifies which parts of the image are being used-like focusing on just the colors or the depth. Options include VK_IMAGE_ASPECT_COLOR_BIT for color data, VK_IMAGE_ASPECT_DEPTH_BIT for depth, or VK_IMAGE_ASPECT_STENCIL_BIT for stencil. For a render pass attachment, this matches what you're writing or reading (e.g., a depth buffer uses VK_IMAGE_ASPECT_DEPTH_BIT). It's a way to tell Vulkan, \"I only care about this piece of the image,\" keeping operations precise and efficient.",
	"Access":               "The Access field, using vk.AccessFlags, describes how the image's memory is accessed during rendering. It's like listing what you're doing with a notebook: VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT means writing colors, VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT means reading depth/stencil data. This ties into subpass dependencies, ensuring one step (like writing) finishes before another (like reading) starts. For an attachment, it reflects how the render pass interacts with the image, helping Vulkan avoid data mix-ups.",
	"AttachmentImageClear": "Controls how the image should be cleared at the beginning of the render pass",
}
